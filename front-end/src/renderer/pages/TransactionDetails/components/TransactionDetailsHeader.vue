<script setup lang="ts">
import type { Transaction } from '@prisma/client';
import type { ITransactionFull } from '@shared/interfaces';
import { TransactionStatus } from '@shared/interfaces';

import { computed, onMounted, reactive, ref, watch } from 'vue';
import { format } from 'date-fns';
import { encode } from 'msgpackr';

import { Transaction as SDKTransaction } from '@hashgraph/sdk';

import { areByteArraysEqual, javaFormatArrayHashCode } from '@shared/utils/byteUtils';

import useUserStore from '@renderer/stores/storeUser';
import useNetwork from '@renderer/stores/storeNetwork';
import useContactsStore from '@renderer/stores/storeContacts';
import useNextTransactionStore from '@renderer/stores/storeNextTransaction';

import { useMediaQuery } from '@vueuse/core';
import { useRouter } from 'vue-router';
import { useToast } from 'vue-toast-notification';
import usePersonalPassword from '@renderer/composables/usePersonalPassword';

import {
  archiveTransaction,
  cancelTransaction,
  executeTransaction,
  getUserShouldApprove,
  remindSigners,
  sendApproverChoice,
  uploadSignatures,
} from '@renderer/services/organization';
import { decryptPrivateKey } from '@renderer/services/keyPairService';
import { saveFileToPath, showSaveDialog } from '@renderer/services/electronUtilsService';

import {
  assertIsLoggedInOrganization,
  assertUserLoggedIn,
  getErrorMessage,
  getLastExportExtension,
  getPrivateKey,
  getStatusFromCode,
  getTransactionBodySignatureWithoutNodeAccountId,
  hexToUint8Array,
  isLoggedInOrganization,
  redirectToDetails,
  setLastExportExtension,
  usersPublicRequiredToSign,
} from '@renderer/utils';

import AppButton from '@renderer/components/ui/AppButton.vue';
import AppModal from '@renderer/components/ui/AppModal.vue';
import AppCustomIcon from '@renderer/components/ui/AppCustomIcon.vue';
import AppDropDown from '@renderer/components/ui/AppDropDown.vue';

/* Types */
type ActionButton =
  | 'Reject'
  | 'Approve'
  | 'Sign'
  | 'Previous'
  | 'Next'
  | 'Cancel'
  | 'Export'
  | 'Submit'
  | 'Remind Signers'
  | 'Archive';

/* Misc */
const reject: ActionButton = 'Reject';
const approve: ActionButton = 'Approve';
const sign: ActionButton = 'Sign';
const previous: ActionButton = 'Previous';
const next: ActionButton = 'Next';
const cancel: ActionButton = 'Cancel';
const execute: ActionButton = 'Submit';
const remindSignersLabel: ActionButton = 'Remind Signers';
const archive: ActionButton = 'Archive';
const exportName: ActionButton = 'Export';

const primaryButtons: ActionButton[] = [reject, approve, sign, next];
const buttonsDataTestIds: { [key: string]: string } = {
  [reject]: 'button-reject-org-transaction',
  [approve]: 'button-approve-org-transaction',
  [sign]: 'button-sign-org-transaction',
  [previous]: 'button-previous-org-transaction',
  [next]: 'button-next-org-transaction',
  [cancel]: 'button-cancel-org-transaction',
  [execute]: 'button-execute-org-transaction',
  [remindSignersLabel]: 'button-remind-signers-org-transaction',
  [archive]: 'button-archive-org-transaction',
  [exportName]: 'button-export-transaction',
};

const EXPORT_FORMATS = [
  {
    name: 'Transaction Tool 2.0 (.tx2)',
    value: 'tt2',
    extensions: ['tx2'],
    enabled: true, // Set to false to hide/remove in the future
  },
  {
    name: 'Transaction Tool (.tx)',
    value: 'tt1',
    extensions: ['tx'],
    enabled: true, // Set to false to hide/remove
  },
];

/* Props */
const props = defineProps<{
  organizationTransaction: ITransactionFull | null;
  localTransaction: Transaction | null;
  sdkTransaction: SDKTransaction | null;
  nextId: number | string | null;
  previousId: number | string | null;
}>();

/* Stores */
const user = useUserStore();
const network = useNetwork();
const contacts = useContactsStore();
const nextTransaction = useNextTransactionStore();

/* Composables */
const router = useRouter();
const toast = useToast();
const isLargeScreen = useMediaQuery('(min-width: 992px)');
const { getPassword, passwordModalOpened } = usePersonalPassword();

/* State */
const isConfirmModalShown = ref(false);
const confirmModalTitle = ref('');
const confirmModalText = ref('');
const confirmModalButtonText = ref('');
const confirmModalLoadingText = ref('');
const confirmCallback = ref<((...args: any[]) => void) | null>(null);

const fullyLoaded = ref(false);
const loadingStates = reactive<{ [key: string]: string | null }>({
  [reject]: null,
  [approve]: null,
  [sign]: null,
});
const isConfirmModalLoadingState = ref(false);

const publicKeysRequiredToSign = ref<string[] | null>(null);
const shouldApprove = ref<boolean>(false);

/* Computed */
const creator = computed(() => {
  return props.organizationTransaction
    ? contacts.contacts.find(contact =>
        contact.userKeys.some(k => k.id === props.organizationTransaction?.creatorKeyId),
      )
    : null;
});

const isCreator = computed(() => {
  if (!creator.value) return false;
  if (!isLoggedInOrganization(user.selectedOrganization)) return false;

  return creator.value.user.id === user.selectedOrganization.userId;
});

const transactionIsInProgress = computed(
  () =>
    props.organizationTransaction &&
    [
      TransactionStatus.NEW,
      TransactionStatus.WAITING_FOR_EXECUTION,
      TransactionStatus.WAITING_FOR_SIGNATURES,
    ].includes(props.organizationTransaction.status),
);

const canCancel = computed(() => {
  return isCreator.value && transactionIsInProgress.value;
});

const canSign = computed(() => {
  if (!props.organizationTransaction || !publicKeysRequiredToSign.value) return false;
  if (!isLoggedInOrganization(user.selectedOrganization)) return false;

  if (isTransactionVersionMismatch.value) {
    toast.error('Transaction version mismatch. Cannot sign.');
    return false;
  }

  const userShouldSign = publicKeysRequiredToSign.value.length > 0;

  return userShouldSign && transactionIsInProgress.value;
});

const canExecute = computed(() => {
  const status = props.organizationTransaction?.status;
  const isManual = props.organizationTransaction?.isManual;

  return (
    status === TransactionStatus.WAITING_FOR_EXECUTION &&
    isManual &&
    isCreator.value &&
    transactionIsInProgress.value
  );
});

const canRemind = computed(() => {
  const status = props.organizationTransaction?.status;

  return (
    status === TransactionStatus.WAITING_FOR_SIGNATURES &&
    isCreator.value &&
    transactionIsInProgress.value
  );
});

const canArchive = computed(() => {
  const isManual = props.organizationTransaction?.isManual;

  return isManual && isCreator.value && transactionIsInProgress.value;
});

const visibleButtons = computed(() => {
  const buttons: ActionButton[] = [];

  if (!fullyLoaded.value) return buttons;

  /* The order is important REJECT, APPROVE, SIGN, SUBMIT, PREVIOUS, NEXT, CANCEL, ARCHIVE, EXPORT */
  shouldApprove.value && buttons.push(reject, approve);
  canSign.value && !shouldApprove.value && buttons.push(sign);
  canExecute.value && buttons.push(execute);
  // if (isLargeScreen.value) {
  //   props.previousId && buttons.push(previous);
  //   props.nextId && buttons.push(next);
  // } else {
  props.nextId && buttons.push(next);
  props.previousId && buttons.push(previous);
  // }
  canCancel.value && buttons.push(cancel);
  canRemind.value && buttons.push(remindSignersLabel);
  canArchive.value && buttons.push(archive);
  buttons.push(exportName);

  return buttons;
});

const dropDownItems = computed(() =>
  visibleButtons.value.slice(1).map(item => ({ label: item, value: item })),
);

const isTransactionFailed = computed(() => {
  return props.organizationTransaction?.status === TransactionStatus.FAILED;
});

const isTransactionVersionMismatch = computed(() => {
  if (!props.sdkTransaction || !props.organizationTransaction) return false;

  // The sdkTransaction has already been deserialized from bytes, serialize back into bytes
  // and compare to the organizations transaction bytes.
  return !areByteArraysEqual(
    props.sdkTransaction.toBytes(),
    hexToUint8Array(props.organizationTransaction.transactionBytes),
  );
});

/* Handlers */
const handleBack = () => {
  if (
    !history.state?.back?.startsWith('/transactions') &&
    !history.state?.back?.startsWith('/transaction-group/')
  ) {
    router.push({ name: 'transactions' });
  } else {
    router.back();
  }
};

const handleSign = async () => {
  if (!(props.sdkTransaction instanceof SDKTransaction) || !props.organizationTransaction) {
    throw new Error('Transaction is not available');
  }

  assertUserLoggedIn(user.personal);
  assertIsLoggedInOrganization(user.selectedOrganization);

  const personalPassword = getPassword(handleSign, {
    subHeading: 'Enter your application password to access your private key',
  });
  if (passwordModalOpened(personalPassword)) return;

  try {
    loadingStates[sign] = 'Signing...';

    const publicKeysRequired = await usersPublicRequiredToSign(
      props.sdkTransaction,
      user.selectedOrganization.userKeys,
      network.mirrorNodeBaseURL,
    );

    const restoredRequiredKeys = [];
    const requiredNonRestoredKeys = [];

    // Separate keys into restored and non-restored, where restored indicates that the
    // key is locally present.
    for (const requiredKey of publicKeysRequired) {
      if (user.keyPairs.some(k => k.public_key === requiredKey)) {
        restoredRequiredKeys.push(requiredKey);
      } else {
        requiredNonRestoredKeys.push(requiredKey);
      }
    }

    if (requiredNonRestoredKeys.length > 0) {
      toast.error(
        `You need to restore the following public keys to fully sign the transaction: ${requiredNonRestoredKeys.join(
          ', ',
        )}`,
      );
    }

    if (restoredRequiredKeys.length > 0) {
      await uploadSignatures(
        user.personal.id,
        personalPassword,
        user.selectedOrganization,
        restoredRequiredKeys,
        SDKTransaction.fromBytes(props.sdkTransaction.toBytes()),
        props.organizationTransaction.id,
      );
      toast.success('Transaction signed successfully');
    }
  } catch (error) {
    toast.error(getErrorMessage(error, 'Failed to sign transaction'));
  } finally {
    loadingStates[sign] = null;
  }
};

const handleApprove = async (approved: boolean, showModal?: boolean) => {
  if (!approved && showModal) {
    confirmModalTitle.value = 'Reject Transaction?';
    confirmModalText.value = 'Are you sure you want to reject the transaction?';
    confirmModalButtonText.value = 'Reject';
    confirmCallback.value = () => handleApprove(false);
    confirmModalLoadingText.value = 'Rejecting...';
    isConfirmModalShown.value = true;
    return;
  }

  const callback = async () => {
    if (!(props.sdkTransaction instanceof SDKTransaction) || !props.organizationTransaction) {
      throw new Error('Transaction is not available');
    }

    assertUserLoggedIn(user.personal);
    assertIsLoggedInOrganization(user.selectedOrganization);

    const personalPassword = getPassword(callback, {
      subHeading: 'Enter your application password to access your private key',
    });
    if (passwordModalOpened(personalPassword)) return;

    try {
      if (approved) {
        loadingStates[approve] = 'Approving...';
      } else {
        loadingStates[reject] = 'Rejecting...';
        isConfirmModalLoadingState.value = true;
      }

      const orgKey = user.selectedOrganization.userKeys.filter(k => k.mnemonicHash)[0];
      const privateKeyRaw = await decryptPrivateKey(
        user.personal.id,
        personalPassword,
        orgKey.publicKey,
      );

      const privateKey = getPrivateKey(orgKey.publicKey, privateKeyRaw);

      const signature = getTransactionBodySignatureWithoutNodeAccountId(
        privateKey,
        props.sdkTransaction,
      );

      await sendApproverChoice(
        user.selectedOrganization.serverUrl,
        props.organizationTransaction.id,
        orgKey.id,
        signature,
        approved,
      );
      toast.success(`Transaction ${approved ? 'approved' : 'rejected'} successfully`);

      if (!approved) {
        router.back();
      }
    } catch (error) {
      isConfirmModalShown.value = false;
      throw error;
    } finally {
      loadingStates[approve] = null;
      loadingStates[reject] = null;
      isConfirmModalLoadingState.value = false;
      confirmModalLoadingText.value = '';
    }
  };

  await callback();
};

const handleTransactionAction = async (
  action: 'cancel' | 'archive' | 'execute' | 'remindSigners',
  showModal?: boolean,
) => {
  assertIsLoggedInOrganization(user.selectedOrganization);
  if (!props.organizationTransaction) {
    throw new Error('Transaction is not available');
  }

  const actionDetails = {
    cancel: {
      title: 'Cancel Transaction?',
      text: 'Are you sure you want to cancel the transaction?',
      buttonText: 'Confirm',
      loadingText: 'Canceling...',
      successMessage: 'Transaction canceled successfully',
      actionFunction: cancelTransaction,
    },
    archive: {
      title: 'Archive Transaction?',
      text: 'Are you sure you want to archive the transaction? The required signers will not be able to sign it anymore.',
      buttonText: 'Confirm',
      loadingText: 'Archiving...',
      successMessage: 'Transaction archived successfully',
      actionFunction: archiveTransaction,
    },
    execute: {
      title: 'Submit Transaction?',
      text: 'The transaction will be scheduled to execute at the specified time and processed automatically.',
      buttonText: 'Confirm',
      loadingText: 'Submitting...',
      successMessage: 'Transaction sent for execution successfully',
      actionFunction: executeTransaction,
    },
    remindSigners: {
      title: 'Remind Signers?',
      text: 'All signers that have not yet signed will be sent a notification.',
      buttonText: 'Confirm',
      loadingText: 'Sending...',
      successMessage: 'Signers reminded successfully',
      actionFunction: remindSigners,
    },
  };

  const { title, text, buttonText, loadingText, successMessage, actionFunction } =
    actionDetails[action];

  if (showModal) {
    confirmModalTitle.value = title;
    confirmModalText.value = text;
    confirmModalButtonText.value = buttonText;
    confirmCallback.value = () => handleTransactionAction(action);
    isConfirmModalShown.value = true;
    return;
  }

  try {
    confirmModalLoadingText.value = loadingText;
    isConfirmModalLoadingState.value = true;
    await actionFunction(user.selectedOrganization.serverUrl, props.organizationTransaction.id);
    toast.success(successMessage);
  } catch (error) {
    isConfirmModalShown.value = false;
    throw error;
  } finally {
    isConfirmModalShown.value = false;
    isConfirmModalLoadingState.value = false;
    confirmModalLoadingText.value = '';
  }
};

const handleCancel = (showModal?: boolean) => handleTransactionAction('cancel', showModal);
const handleArchive = (showModal?: boolean) => handleTransactionAction('archive', showModal);
const handleExecute = (showModal?: boolean) => handleTransactionAction('execute', showModal);
const handleRemindSigners = (showModal?: boolean) =>
  handleTransactionAction('remindSigners', showModal);

const handlePrevious = () => {
  if (!props.previousId) return;

  const newPreviousTransactionsIds = [...(nextTransaction.previousTransactionsIds || [])];
  if (isLoggedInOrganization(user.selectedOrganization)) {
    props.organizationTransaction &&
      newPreviousTransactionsIds.push(props.organizationTransaction.id);
  } else {
    props.localTransaction && newPreviousTransactionsIds.push(props.localTransaction.id);
  }
  nextTransaction.setPreviousTransactionsIds(newPreviousTransactionsIds);

  redirectToDetails(router, props.previousId.toString(), true, true);
};

const handleNext = () => {
  if (!props.nextId) return;

  const newPreviousTransactionsIds = [...(nextTransaction.previousTransactionsIds || [])];
  if (isLoggedInOrganization(user.selectedOrganization)) {
    props.organizationTransaction &&
      newPreviousTransactionsIds.push(props.organizationTransaction.id);
  } else {
    props.localTransaction && newPreviousTransactionsIds.push(props.localTransaction.id);
  }
  nextTransaction.setPreviousTransactionsIds(newPreviousTransactionsIds);

  redirectToDetails(router, props.nextId.toString(), true, true);
};

const handleExport = async () => {
  if (!props.sdkTransaction) {
    throw new Error('(BUG) Transaction is not available');
  }

  assertUserLoggedIn(user.personal);

  /* Verifies the user has entered his password */
  const personalPassword = getPassword(handleExport, {
    subHeading: 'Enter your application password to export the transaction',
  });
  if (passwordModalOpened(personalPassword)) return;

  // Load the last export format the user selected, if applicable
  const enabledFormats = EXPORT_FORMATS.filter(f => f.enabled);
  const defaultFormat = getLastExportExtension() || (enabledFormats[0] || EXPORT_FORMATS[0]).extensions[0];

  // Move the default format to the top
  enabledFormats.sort((a, b) => (a.extensions[0] === defaultFormat ? -1 : 1));

  // Show the save dialog to the user, allowing them to choose the file name and location

  // Continue to use the same format as TTv1, for now.
  // The default format based on TTv1 is as follows:
  // `${epochSeconds}_${accountId}_${hash}.tx`
  const validStart = props.sdkTransaction.transactionId.validStart;
  const accountId = props.sdkTransaction.transactionId.accountId.toString();

  const hash = javaFormatArrayHashCode(props.sdkTransaction.toBytes());
  const defaultName = `${validStart.seconds}_${accountId}_${hash}`;

  const { filePath, canceled } = await showSaveDialog(
    `${defaultName || 'transaction'}`,
    'Export transaction',
    'Export',
    enabledFormats,
    'Export transaction',
  );

  if (canceled || !filePath) {
    return;
  }

  // Save selected format to local storage
  const ext = filePath.split('.').pop();
  if (!EXPORT_FORMATS.find(f => f.extensions[0] === ext)) {
    throw new Error(`Unsupported file extension: ${ext}`);
  }
  setLastExportExtension(ext);

  // Create file(s) based on name and selected format
  if (ext === 'tx2') {
    // TTv2 is the new format, which includes the entire transaction, comments, and any other
    // metadata that might be relevant.
    const bytes = encode(props.organizationTransaction);
    await saveFileToPath(
      bytes,
      filePath,
    );

    toast.success('Transaction exported successfully');
  } else if (ext === 'tx') {
    // Remove all signatures, 'unfreeze' it, then set nodes. This gives us the 'base' transaction.
    const mainTransaction = SDKTransaction.fromBytes(props.sdkTransaction.toBytes());

    if (user.publicKeys.length === 0) {
      throw new Error('Exporting in the .tx format requires a signature. User must have at least one key pair to sign the transaction.');
    }
    const publicKey = user.publicKeys[0]; // get the first key pair's public key

    const privateKeyRaw = await decryptPrivateKey(user.personal.id, personalPassword, publicKey);
    const privateKey = getPrivateKey(publicKey, privateKeyRaw);

    const bytes = (await mainTransaction.sign(privateKey)).toBytes();
    await saveFileToPath(bytes, filePath);

    // now create txt
    const author = props.organizationTransaction.creatorEmail;
    const contents = props.organizationTransaction.description || '';
    const timestamp = new Date(props.organizationTransaction.createdAt);
    const formattedTimestamp = format(timestamp, 'yyyy-MM-dd HH:mm:ss');

    const exportJson = JSON.stringify({
      Author: author,
      Contents: contents,
      Timestamp: formattedTimestamp,
    });

    const txtFilePath = filePath.replace(/\.[^/.]+$/, '.txt');

    await saveFileToPath(
      exportJson,
      txtFilePath,
    );

    // If the CSVA file is created, then TTv1 will attempt to recreate
    // each inner transaction value by value, not by bytes.
    // This means that the first transaction signed will work correctly,
    // but any other transactions will have different bytes than expected. Do not create the CSVA
    // This code can be removed once testing is finished
    // const accountNums: number[] = [];
    // const list: Array<{ realmNum: number; shardNum: number; accountNum: number; network: string }> = [];
    //
    // for (let i = 0; i < nodeAccountIds.length; i++) {
    //   const id = nodeAccountIds.get(i);
    //   accountNums.push(id.num ?? 0);
    //   list.push({
    //     realmNum: id.realm?.toString() ?? 0,
    //     shardNum: id.shard?.toString() ?? 0,
    //     accountNum: id.num?.toString() ?? 0,
    //     network: network.network,
    //   });
    // }
    //
    // // Build input string (e.g. "3-5,7")
    // const sorted = accountNums.sort((a, b) => a - b);
    // const ranges: string[] = [];
    // let start = sorted[0], end = sorted[0];
    // function addRange(start: Long, end: Long) {
    //   ranges.push(start.equals(end) ? `${start.toString()}` : `${start.toString()}-${end.toString()}`);
    // }
    // for (let i = 1; i < sorted.length; i++) {
    //   if (sorted[i].equals(end.add(1))) {
    //     end = sorted[i];
    //   } else {
    //     addRange(start, end);
    //     start = sorted[i];
    //     end = sorted[i];
    //   }
    // }
    // addRange(start, end);
    // const input = ranges.join(',');
    //
    // const metadata = JSON.stringify({
    //   nodes: {
    //     input,
    //     list,
    //   }
    // });
    //
    // const csvaFilePath = filePath.replace(/\.[^/.]+$/, '.csva');
    //
    // // now create csva
    // await saveFileToPath(
    //   metadata,
    //   csvaFilePath,
    // );

    toast.success('Transaction exported successfully');
  }
};

const handleAction = async (value: ActionButton) => {
  if (value === reject) {
    await handleApprove(false, true);
  } else if (value === approve) {
    await handleApprove(true, true);
  } else if (value === sign) {
    await handleSign();
  } else if (value === next) {
    await handleNext();
  } else if (value === previous) {
    await handlePrevious();
  } else if (value === cancel) {
    await handleCancel(true);
  } else if (value === archive) {
    await handleArchive(true);
  } else if (value === execute) {
    await handleExecute(true);
  } else if (value === exportName) {
    await handleExport();
  } else if (value === remindSignersLabel) {
    await handleRemindSigners(true);
  }
};
const handleSubmit = async (e: Event) => {
  const buttonContent = (e as SubmitEvent).submitter?.textContent || '';
  await handleAction(buttonContent as ActionButton);
};

const handleDropDownItem = async (value: ActionButton) => handleAction(value);

/* Hooks */
onMounted(() => {
  if (!isLoggedInOrganization(user.selectedOrganization)) {
    fullyLoaded.value = true;
  }
});

/* Watchers */
watch(
  () => props.organizationTransaction,
  async transaction => {
    assertIsLoggedInOrganization(user.selectedOrganization);

    fullyLoaded.value = false;

    if (!transaction) {
      publicKeysRequiredToSign.value = null;
      shouldApprove.value = false;
      return;
    }

    const results = await Promise.allSettled([
      usersPublicRequiredToSign(
        SDKTransaction.fromBytes(hexToUint8Array(transaction.transactionBytes)),
        user.selectedOrganization.userKeys,
        network.mirrorNodeBaseURL,
      ),
      getUserShouldApprove(user.selectedOrganization.serverUrl, transaction.id),
    ]);

    results[0].status === 'fulfilled' && (publicKeysRequiredToSign.value = results[0].value);
    results[1].status === 'fulfilled' && (shouldApprove.value = results[1].value);

    fullyLoaded.value = true;

    results.forEach(
      r =>
        r.status === 'rejected' &&
        toast.error(getErrorMessage(r.reason, 'Failed to load transaction details')),
    );
  },
);
</script>
<template>
  <form
    @submit.prevent="handleSubmit"
    class="flex-centered justify-content-between flex-wrap gap-4"
  >
    <div class="d-flex align-items-center">
      <AppButton
        type="button"
        color="secondary"
        class="btn-icon-only me-4"
        data-testid="button-back"
        @click="handleBack"
      >
        <i class="bi bi-arrow-left"></i>
      </AppButton>

      <h2 class="text-title text-bold">
        Transaction Details
        <span v-if="isTransactionFailed" class="badge bg-danger text-break ms-2">
          {{
            getStatusFromCode(props.organizationTransaction?.statusCode)
              ? getStatusFromCode(props.organizationTransaction?.statusCode)
              : 'FAILED'
          }}
        </span>
        <span v-else-if="isTransactionVersionMismatch" class="badge bg-danger text-break ms-2">
          Transaction Version Mismatch
        </span>
      </h2>
    </div>

    <div class="flex-centered gap-4">
      <Transition name="fade" mode="out-in">
        <template v-if="visibleButtons.length > 0">
          <div>
            <AppButton
              :color="primaryButtons.includes(visibleButtons[0]) ? 'primary' : 'secondary'"
              :loading="Boolean(loadingStates[visibleButtons[0]])"
              :loading-text="loadingStates[visibleButtons[0]] || ''"
              :data-testid="buttonsDataTestIds[visibleButtons[0]]"
              type="submit"
              class="me-3"
              >{{ visibleButtons[0] }}
            </AppButton>
          </div>
        </template>
      </Transition>

      <Transition name="fade" mode="out-in">
        <template v-if="visibleButtons.length > 1">
          <div class="d-none d-lg-block">
            <AppButton
              :color="primaryButtons.includes(visibleButtons[1]) ? 'primary' : 'secondary'"
              :loading="Boolean(loadingStates[visibleButtons[1]])"
              :loading-text="loadingStates[visibleButtons[1]] || ''"
              :data-testid="buttonsDataTestIds[visibleButtons[1]]"
              type="submit"
              class="me-3"
              >{{ visibleButtons[1] }}
            </AppButton>
          </div>
        </template>
      </Transition>

      <Transition name="fade" mode="out-in">
        <template v-if="visibleButtons.length > 2">
          <div>
            <AppDropDown
              class="d-lg-none"
              :color="'secondary'"
              :items="dropDownItems"
              compact
              @select="handleDropDownItem($event as ActionButton)"
            />
            <AppDropDown
              class="d-none d-lg-block"
              :color="'secondary'"
              :items="dropDownItems.slice(1)"
              compact
              @select="handleDropDownItem($event as ActionButton)"
            />
          </div>
        </template>
        <template v-else-if="visibleButtons.length === 2">
          <div class="d-lg-none">
            <AppButton
              :color="primaryButtons.includes(visibleButtons[1]) ? 'primary' : 'secondary'"
              :loading="Boolean(loadingStates[visibleButtons[1]])"
              :loading-text="loadingStates[visibleButtons[1]] || ''"
              :data-testid="buttonsDataTestIds[visibleButtons[1]]"
              type="submit"
              class="me-3"
              >{{ visibleButtons[1] }}
            </AppButton>
          </div>
        </template>
      </Transition>
    </div>
  </form>

  <AppModal v-model:show="isConfirmModalShown" class="common-modal">
    <div class="p-4">
      <i class="bi bi-x-lg d-inline-block cursor-pointer" @click="isConfirmModalShown = false"></i>
      <div class="text-center">
        <AppCustomIcon :name="'questionMark'" style="height: 160px" />
      </div>
      <h3 class="text-center text-title text-bold mt-4">{{ confirmModalTitle }}</h3>
      <p class="text-center text-small text-secondary mt-4">
        {{ confirmModalText }}
      </p>
      <hr class="separator my-5" />
      <div class="flex-between-centered gap-4">
        <AppButton color="borderless" @click="isConfirmModalShown = false">Cancel</AppButton>
        <AppButton
          color="primary"
          data-testid="button-confirm-change-password"
          @click="confirmCallback && confirmCallback()"
          :disabled="isConfirmModalLoadingState"
          :loading="isConfirmModalLoadingState"
          :loading-text="confirmModalLoadingText"
          >{{ confirmModalButtonText }}</AppButton
        >
      </div>
    </div>
  </AppModal>
</template>
